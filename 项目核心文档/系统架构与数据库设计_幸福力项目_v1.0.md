# 幸福力婚恋系统架构与数据库设计文档

| 文档版本 | 日期 | 编写 | 说明 |
| :--- | :--- | :--- | :--- |
| v1.0 | 2026-01-11 | AI Assistant | 基于PRD v1.0进行技术架构与数据建模 |

本文档详细描述了“幸福力”项目的技术实现方案，重点在于**多租户数据隔离**的底层设计、**动态档案**的存储结构以及**核心算法**的技术落地。

---

## 1. 技术栈选型 (Tech Stack)

### 1.1 后端技术栈
*   **开发语言**：Java (Spring Boot) 或 Python (Django/FastAPI) / Node.js (NestJS)
    *   *建议使用 Java Spring Boot，因其在企业级复杂业务、强类型约束及生态成熟度上的优势，适合处理复杂的匹配算法和多租户逻辑。*
*   **数据库**：MySQL 8.0+
    *   *利用 JSON 类型存储复杂的测评答卷和非结构化档案数据。*
*   **缓存中间件**：Redis
    *   *用于 Token 存储、ID 生成器的原子计数、高频配置缓存。*
*   **对象存储**：腾讯云 COS / 阿里云 OSS
    *   *存储用户大头照、测评结果生成的图片等。*

### 1.2 前端技术栈
*   **前台 H5**：Vue 3 / React + Vant UI (移动端适配)
*   **后台 Web**：Vue 3 / React + Ant Design Pro (企业级后台)
*   **UI 组件策略**：
    *   核心组件（表单、按钮等）使用 Vant 4。
    *   **全局反馈 (Toast)**：为确保兼容性，采用自定义轻量级封装 `utils/toast.ts`，不依赖第三方库样式。

---

## 2. 系统架构设计

### 2.1 多租户隔离策略 (Tenant Isolation)
系统采用 **"共享数据库，共享数据表" (Shared Database, Shared Schema)** 模式，通过 `store_id` 字段在应用层进行逻辑隔离。

*   **数据层**：所有业务表（用户、档案、匹配记录等）均强制包含 `store_id` 字段。
*   **中间件层 (MyBatis/Hibernate Interceptor)**：
    *   实现 SQL 拦截器，自动在查询条件中注入 `WHERE store_id = current_user.store_id`。
    *   超级管理员 (Super Admin) 可通过特殊标记绕过此拦截器进行全局查询。

### 2.2 ID 生成器架构
为了满足 PRD 中特定的 ID 格式规则（如 `XFL001G13702`），不能使用数据库自增 ID 或 UUID。

*   **方案**：**Redis 原子计数器 (INCR) + 格式化策略**
*   **流程**：
    1.  **门店 ID**：`XFL` + Redis Key `sys:store:seq` (3位，补0)。
    2.  **用户 ID**：
        *   前缀：`Current_Store_ID` (如 XFL001)。
        *   后缀：Redis Key `sys:user:seq:{store_id}` (5位)。
        *   **混淆策略**：为避免ID连续暴露业务量，采用 **线性同余生成器 (LCG)** 或 **Feistel Cipher** 算法，将 Redis 的连续序列号映射为伪随机的唯一数字（即需求中的“随机偏移量”），保证全局唯一且不可预测。

---

## 3. 数据库设计 (Schema Design)

### 3.1 核心实体关系图 (Simplified ER Diagram)

```mermaid
erDiagram
    sys_store ||--o{ sys_user : "拥有后台人员"
    sys_store ||--o{ app_user : "拥有前台会员"
    app_user ||--|| app_user_profile : "关联档案"
    app_user ||--o{ assessment_record : "进行测评"
    app_user ||--o{ match_batch : "发起匹配"
    match_batch ||--o{ match_detail : "包含候选人"
    app_user ||--o{ service_track : "产生服务轨迹"
```

### 3.2 详细表结构定义

#### A. 基础管理模块

**1. 门店表 (`sys_store`)**
| 字段名 | 类型 | 说明 | 索引 |
| :--- | :--- | :--- | :--- |
| **id** | CHAR(6) | PK, 门店ID (如 XFL001) | PRIMARY |
| name | VARCHAR(50) | 门店名称 | |
| mv_template_id | INT | 绑定的MV地域方案ID (1-5) | |
| region_info | JSON | 省市区地址信息 | |
| status | TINYINT | 1:正常, 0:禁用 | |
| created_at | DATETIME | | |

**2. 后台用户表 (`sys_user`)**
| 字段名 | 类型 | 说明 | 索引 |
| :--- | :--- | :--- | :--- |
| **id** | VARCHAR(20) | PK, 后台用户ID (XFL001G...) | PRIMARY |
| store_id | CHAR(6) | 所属门店 | IDX_STORE |
| username | VARCHAR(50) | 登录账号/姓名 | |
| password | VARCHAR(100) | 加密密码 (BCrypt) | |
| role | VARCHAR(20) | 角色: super_admin(超管), admin(老板), manager(负责人), matchmaker(红娘) | |
| status | TINYINT | 1:正常, 0:待审核, -1:禁用 | |

#### B. 用户档案模块

**3. 前台用户表 (`app_user`)**
| 字段名 | 类型 | 说明 | 索引 |
| :--- | :--- | :--- | :--- |
| **id** | VARCHAR(20) | PK, 前台用户ID (XFL001...) | PRIMARY |
| store_id | CHAR(6) | 所属门店 | IDX_STORE |
| phone | VARCHAR(20) | 手机号 (唯一索引需组合 store_id 吗? 建议全局唯一) | UNIQUE |
| password | VARCHAR(100) | 加密密码 | |
| created_at | DATETIME | 注册时间 | |

**4. 用户档案表 (`app_user_profile`)**
*核心表，包含同步字段与编辑字段。*
| 字段名 | 类型 | 说明 |
| :--- | :--- | :--- |
| **user_id** | VARCHAR(20) | PK, FK -> app_user.id |
| **base_info** | JSON | **同步字段集合**：{name, gender, birthday, height, weight, education, marriage, ...} |
| **ext_info** | JSON | **编辑字段集合**：{income, house, car, appearance_score, family_bg, ...} |
| **mv_score** | DECIMAL(5,2) | 当前计算出的MV总分 |
| mv_detail | JSON | MV各维度得分详情：{age_score: 12.5, bmi_score: 10.5, ...} |
| service_matchmaker_id | VARCHAR(20) | 服务红娘ID |
| updated_at | DATETIME | 档案更新时间 (用于触发MV重算) |

> **设计思路**：考虑到档案字段极多且可能调整，将核心用于搜索筛选的字段（如年龄、身高、学历）设为独立列（Virtual Generated Columns 可选），其余大量描述性字段存入 JSON，既保证灵活性又支持高效索引。

#### C. 测评与业务模块

**5. 测评记录表 (`assessment_record`)**
| 字段名 | 类型 | 说明 |
| :--- | :--- | :--- |
| id | BIGINT | PK, 自增 |
| user_id | VARCHAR(20) | FK |
| type | TINYINT | 1:九型, 2:依恋, 3:幸福力 |
| answers | JSON | 原始答卷数据 |
| **result_data** | JSON | 结构化结果：<br>九型: {top3: [2,1,3], percentages: {...}}<br>依恋: {type: "安全型", scores: {A:2, B:1...}}<br>幸福力: {scores: [8,9,6...]} |
| created_at | DATETIME | |

**6. 匹配批次表 (`match_batch`)**
| 字段名 | 类型 | 说明 |
| :--- | :--- | :--- |
| id | BIGINT | PK |
| store_id | CHAR(6) | 门店隔离 |
| initiator_id | VARCHAR(20) | 发起方用户ID |
| filter_criteria | JSON | 当时的筛选条件快照 |
| created_at | DATETIME | 匹配发起时间 |

**7. 匹配明细表 (`match_detail`)**
| 字段名 | 类型 | 说明 |
| :--- | :--- | :--- |
| id | BIGINT | PK |
| batch_id | BIGINT | FK -> match_batch.id |
| candidate_id | VARCHAR(20) | 候选方用户ID |
| mv_diff | DECIMAL(4,2) | MV分差 |
| is_mv_pass | TINYINT | MV是否通过 |
| is_personality_pass| TINYINT | 九型是否通过 |
| result_status | TINYINT | 最终系统判定: 1通过, 0不通过 |

**8. 服务轨迹表 (`service_track`)**
*实现双向关联的核心表*
| 字段名 | 类型 | 说明 | 索引 |
| :--- | :--- | :--- | :--- |
| id | BIGINT | PK | |
| store_id | CHAR(6) | | |
| **initiator_id** | VARCHAR(20) | 本方用户ID | IDX_INIT |
| **target_id** | VARCHAR(20) | 对方用户ID (关联对象) | IDX_TARGET |
| type | TINYINT | 1:匹配反馈, 2:约见记录, 3:治疗记录 | |
| status | TINYINT | 进度状态 (如: 看中/未看中, 已约见/反馈) | |
| feedback_content | TEXT | 详细反馈内容/治疗记录 | |
| event_time | DATETIME | 匹配/约见时间 | |
| created_by | VARCHAR(20) | 记录人(红娘ID) | |

---

## 4. 核心功能技术实现方案

### 4.1 动态 MV 计算引擎
由于 MV 计算依赖地域方案（5套规则）和用户档案（实时变动），采用 **策略模式 (Strategy Pattern) + 事件驱动** 实现。

1.  **定义规则接口**：`MvCalculationStrategy`，包含 `calculateMale()` 和 `calculateFemale()`。
2.  **实现5套策略**：`GuangdongStrategy`, `JiangzheStrategy` 等，硬编码或配置化具体的评分区间规则。
3.  **触发机制**：
    *   当 `app_user_profile` 表发生 `UPDATE` 操作。
    *   发布 `UserProfileUpdatedEvent`。
    *   监听器捕获事件 -> 获取用户门店 -> 获取门店绑定的 MV 模板 ID。
    *   调用对应策略计算总分及明细 -> 更新 `mv_score` 和 `mv_detail` 字段。

### 4.2 九型人格匹配算法
*   **数据结构**：在内存中定义 9x9 的匹配矩阵 `int[][] MATCH_MATRIX`，存储 +1, 0, -1。
*   **计算流程**：
    ```java
    // 伪代码
    List<Integer> maleTypes = male.getTop3Types(); // e.g., [1, 3, 5]
    List<Integer> femaleTypes = female.getTop3Types();
    
    boolean isPass = true;
    int matchCount = 0;
    
    for (int m : maleTypes) {
        for (int f : femaleTypes) {
            int score = MATCH_MATRIX[m][f];
            if (score == -1) {
                isPass = false; // 一票否决
                break;
            }
            if (score == 1) {
                matchCount++; // 记录重合度
            }
        }
        if (!isPass) break;
    }
    ```

### 4.3 门店数据隔离方案 (MyBatis Plus 示例)
利用 `TenantLineInnerInterceptor` 插件实现透明隔离。

```java
public class StoreIsolationHandler implements TenantLineHandler {
    @Override
    public Expression getTenantId() {
        // 从 ThreadLocal / SecurityContext 中获取当前登录红娘的 store_id
        String storeId = SecurityContextHolder.getUser().getStoreId();
        return new StringValue(storeId);
    }

    @Override
    public String getTenantIdColumn() {
        return "store_id";
    }

    @Override
    public boolean ignoreTable(String tableName) {
        // 超级管理员操作或非业务表可忽略
        return "sys_store".equals(tableName) || UserContext.isSuperAdmin();
    }
}
```

---

## 5. 接口设计规范 (API Design)

遵循 RESTful 风格，所有接口统一前缀 `/api/v1`。

> **命名约定**：
> *   **API 层**：请求参数与响应 JSON 数据统一使用 **驼峰命名法 (camelCase)**（如 `storeId`, `createdAt`）。
> *   **数据库层**：表名与字段名统一使用 **蛇形命名法 (snake_case)**（如 `store_id`, `created_at`）。
> *   **后端映射**：TypeORM Entity 需显式配置 `@Column({ name: 'snake_case_name' })` 以确保映射正确。

### 5.1 鉴权与上下文
*   **Header**: `Authorization: Bearer <token>`
*   **Token Payload**: 包含 `uid`, `role`, `store_id`。后端收到请求后解析 Token，将 `store_id` 注入请求上下文，供数据库隔离插件使用。

### 5.2 核心接口示例

*   `POST /api/v1/assessments/enneagram` : 提交九型人格测试，返回计算结果。
*   `POST /api/v1/matches/initiate` : 发起匹配。
    *   Payload: `{ initiator_id: "...", criteria: { age_min: 25, ... } }`
    *   Response: `{ batch_id: 101, results: [ { candidate_id: "...", match_score: 95, ... } ] }`
*   `GET /api/v1/profiles/{id}` : 获取用户档案（包含根据权限过滤的敏感字段）。

---

## 6. 安全性设计

1.  **字段脱敏**：使用 Jackson Serializer，在 JSON 序列化阶段检查当前用户角色。若为“普通红娘”，则将 `app_user.phone` 字段掩码处理 (138****1234)。
2.  **ID 防猜测**：如前所述，用户 ID 虽然包含门店信息，但序列号部分应经过混淆，防止通过 ID 自增规律爬取数据。
3.  **越权防御**：所有涉及 `user_id` 的操作，必须校验该用户是否属于当前操作者的 `store_id`（虽然数据库层有隔离，业务层仍需二次校验以防逻辑漏洞）。

