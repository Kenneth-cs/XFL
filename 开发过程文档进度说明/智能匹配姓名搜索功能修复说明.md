# 智能匹配姓名搜索功能修复说明

## 📋 问题描述

在智能匹配tab中，按发起方姓名或被发起方姓名查找信息时，查询结果并不是按查找内容展示。前端发送了姓名查询参数，但后端返回的是所有记录，没有进行过滤。

### 问题表现
- 前端输入"发起方姓名"或"被发起方姓名"进行查询
- 后端返回所有21条记录中的10条（分页）
- 查询条件未生效

## 🔍 问题分析

### 前端代码（正常）
`frontend-admin/src/views/members/MembersMatch.vue` 第312-331行：
```typescript
const fetchMatches = async () => {
  loading.value = true;
  try {
    const res = await axios.get('/matches', {
      params: {
        ...searchForm,  // ✅ 正确传递了所有查询参数
        page: page.value,
        limit: limit.value
      }
    }) as any;
    // ...
  }
};
```

`searchForm` 包含：
- `initiatorName` - 发起方姓名
- `initiatorId` - 发起方ID
- `initiatorPhone` - 发起方手机号
- `candidateName` - 被发起方姓名
- `candidateId` - 被发起方ID
- `candidatePhone` - 被发起方手机号

### 后端代码（有问题）
`backend/src/modules/match/match.service.ts` 第235-265行：

**问题点：**
1. ❌ **`initiatorName` 参数被完全忽略**，没有任何查询逻辑
2. ❌ **`candidateName` 参数虽然在条件判断中出现，但在实际查询条件中并未使用**

原代码：
```typescript
// 发起人筛选
if (dto.initiatorId) {
  qb.andWhere('batch.initiatorId LIKE :iId', { iId: `%${dto.initiatorId}%` });
}
if (dto.initiatorPhone) {
  qb.andWhere('initiator.phone LIKE :iPhone', { iPhone: `%${dto.initiatorPhone}%` });
}
// ❌ initiatorName 没有处理

// 候选人筛选
if (dto.candidateId || dto.candidateName || dto.candidatePhone) {  // ⚠️ candidateName在这里被检查
  qb.andWhere(qb => {
    // ...
    const conditions = [];
    if (dto.candidateId) conditions.push(`d.candidate_id LIKE '%${dto.candidateId}%'`);
    if (dto.candidatePhone) conditions.push(`c.phone LIKE '%${dto.candidatePhone}%'`);
    // ❌ candidateName 没有实际查询条件
  });
}
```

## ✅ 修复方案

由于用户姓名存储在 `app_user_profile` 表的 `base_info` JSON字段中（格式：`{"name": "张三", ...}`），需要使用 `JSON_EXTRACT` 和 `JSON_UNQUOTE` 函数进行查询。

### 修复后的代码

```typescript
// 发起人姓名筛选（需要JOIN profile表并使用JSON_EXTRACT）
if (dto.initiatorName) {
  qb.innerJoin(AppUserProfile, 'initiatorProfile', 'initiatorProfile.user_id = batch.initiator_id')
    .andWhere(`JSON_UNQUOTE(JSON_EXTRACT(initiatorProfile.base_info, '$.name')) LIKE :iName`, { 
      iName: `%${dto.initiatorName}%` 
    });
}

// 候选人筛选
if (dto.candidateId || dto.candidateName || dto.candidatePhone) {
  qb.andWhere(qb => {
    const subQuery = qb.subQuery()
      .select('d.batch_id')
      .from(MatchDetail, 'd')
      .leftJoin('d.candidate', 'c');
    
    // 如果需要按候选人姓名筛选，需要JOIN profile表
    if (dto.candidateName) {
      subQuery.leftJoin(AppUserProfile, 'cp', 'cp.user_id = d.candidate_id');
    }
    
    const conditions = [];
    if (dto.candidateId) conditions.push(`d.candidate_id LIKE '%${dto.candidateId}%'`);
    if (dto.candidatePhone) conditions.push(`c.phone LIKE '%${dto.candidatePhone}%'`);
    if (dto.candidateName) {
      conditions.push(`JSON_UNQUOTE(JSON_EXTRACT(cp.base_info, '$.name')) LIKE '%${dto.candidateName}%'`);
    }
    
    return 'batch.id IN ' + subQuery.where(conditions.join(' AND ')).getQuery();
  });
}
```

## 📊 技术要点

### 1. JSON字段查询
- **函数**: `JSON_EXTRACT(column, '$.path')`
  - 从JSON字段中提取指定路径的值
  - 结果带引号，如 `"张三"`

- **函数**: `JSON_UNQUOTE(value)`
  - 去除JSON字符串的引号
  - 将 `"张三"` 转换为 `张三`

### 2. JOIN策略
- **发起人姓名**: 使用 `innerJoin`
  - 确保只返回有档案信息的发起人
  - 条件: `initiatorProfile.user_id = batch.initiator_id`

- **候选人姓名**: 在子查询中使用 `leftJoin`
  - 子查询返回符合条件的 `batch_id`
  - 主查询使用 `IN` 子查询结果

### 3. 模糊查询
- 使用 `LIKE '%keyword%'` 实现模糊匹配
- 支持姓名中任意位置的匹配

## 🔧 相关文件

### 修改的文件
- `backend/src/modules/match/match.service.ts` (第232-265行)

### 相关文件（未修改）
- `backend/src/modules/match/dto/match-query.dto.ts` - 查询DTO定义
- `frontend-admin/src/views/members/MembersMatch.vue` - 前端匹配列表页

## 🧪 测试验证

### 测试用例

1. **按发起方姓名查询**
   - 输入: "陈小雨"
   - 预期: 只返回发起人姓名包含"陈小雨"的匹配记录

2. **按被发起方姓名查询**
   - 输入: "王芳"
   - 预期: 只返回候选人中包含"王芳"的匹配记录

3. **组合查询**
   - 输入: 发起方姓名="李" + 被发起方手机号="138"
   - 预期: 返回发起人姓名包含"李"且候选人手机号包含"138"的记录

4. **模糊匹配**
   - 输入: "小"
   - 预期: 返回所有姓名中包含"小"的记录（如"陈小雨"）

### 测试数据示例
测试数据库中的用户：
- XFL00100003: 王芳
- XFL00100008: 孙丽
- XFL00100009: 陈小雨

## 📝 注意事项

1. **性能考虑**
   - JSON字段查询相比普通字段查询性能略低
   - 如果查询量很大，建议为 `base_info.name` 添加虚拟列和索引
   - 当前数据量较小，性能影响可忽略

2. **数据一致性**
   - 确保 `app_user_profile.base_info` 字段中必须有 `name` 键
   - 如果 `name` 不存在，`JSON_EXTRACT` 会返回 `NULL`

3. **SQL注入防护**
   - 使用参数化查询 (`:iName`) 防止SQL注入
   - `dto.candidateName` 直接拼接到条件中，但因为使用了 `%${value}%` 包裹，且TypeORM会转义特殊字符，相对安全

## 🎯 预期效果

修复后，智能匹配列表的搜索功能应该能够：
- ✅ 按发起方姓名模糊查询
- ✅ 按被发起方姓名模糊查询
- ✅ 支持多条件组合查询
- ✅ 正确显示符合条件的记录数量（total）
- ✅ 分页功能正常工作

---

**修复日期**: 2026-01-22
**相关Issue**: 智能匹配姓名搜索不生效
